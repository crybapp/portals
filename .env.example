# The environment the app is running in, either production, staging or development
NODE_ENV=

# Port which @cryb/portals should listen on
PORT=1337

# The base REST endpoint that is used to talk to @cryb/api
API_URL=http://localhost:4000
# This should the same secure key in @cryb/api/.env under 'PORTALS_API_KEY'
API_KEY=api-portals-key

# This should the same secure key in @cryb/portal/.env under 'PORTALS_KEY'
PORTAL_KEY=portals-portal-key

# The URI used for connecting to the MongoDB database
MONGO_URI=
# The URI used for connecting to Redis instance
REDIS_URI=
# If you're using redis-ha on Kubernetes, set the URI for the Sentinel below
# Make sure to uncomment the below line and uncomment the REDIS_URI line above
# REDIS_SENTINELS=

# EXPERIMENTAL: Enable dynamic spawning of VM instances when none are available
ENABLE_DYNAMIC_VMS=false
# The amount of random words that should be chosen for a dynamic vm name. Defaults to 2
DYNAMIC_VM_NAME_WORD_COUNT=2
# The maximum amount of servers that can be deployed dynamically
MAX_VM_COUNT=10

# Optional: the JSON Google Application Credentials used for gcloud.driver
# GOOGLE_APPLICATION_CREDENTIALS=

# Optional: configuration for kubernetes.driver
# The URL of the registry the image for the portal is located at
# K8S_PORTAL_IMAGE_REGISTRY_URL=
# The name of the secret for pulling the image from the registry
# K8S_PORTAL_IMAGE_PULL_SECRET=

# The name of the secret for the container env variables
# K8S_PORTAL_ENV_SECRET=

# The requested CPU limit for the portal instance
# K8S_PORTAL_CPU_LIMIT=
# The requested memory limit for the portal instance
# K8S_PORTAL_MEMORY_LIMIT=
# The requested CPU for the portal instance
# K8S_PORTAL_CPU_REQUESTED=
# The requested memory for the portal instance
# K8S_PORTAL_MEMORY_REQUESTED=
